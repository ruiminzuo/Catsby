# 哈希表😊

## 1. 什么是哈希表（`unordered_map`）？

- 哈希表是一种**键值对（key-value）** 数据结构。
- 在 C++ 中，常用 **`unordered_map<KeyType, ValueType>`** 表示，它在内部用哈希函数实现，**查找、插入、删除平均时间复杂度是 O(1)**。
- 和 `map` 不同的是：
  - `map` 是**有序**的，底层是红黑树，查找 O(log n)
  - `unordered_map` 是**无序**的，底层是哈希表，查找 O(1) 平均

------

## 2. 基本语法

### （1）定义

```
#include <unordered_map>
unordered_map<int, int> mp;    // 键和值都是 int
unordered_map<string, int> mp2; // 键是 string，值是 int
```

### （2）插入元素

```
mp[10] = 5;          // 将 key=10, value=5 存入哈希表
mp.insert({20, 8});  // 插入 key=20, value=8
```

> 注意：如果 `key` 已存在，`mp[key]=value` 会更新值。

### （3）访问元素

```
cout << mp[10];    // 输出 key=10 对应的值（如果 key 不存在，会默认插入 value=0）
```

**安全访问**（避免默认插入）：

```
if (mp.find(10) != mp.end()) {
    cout << mp[10]; 
}
```

### （4）查找元素

```
if (mp.find(10) != mp.end()) {
    cout << "存在 key=10" << endl;
}

if (mp.count(10)) { // count(key) 返回 0 或 1
    cout << "存在 key=10" << endl;
}
```

### （5）删除元素

```
mp.erase(10);   // 删除 key=10
```

### （6）遍历哈希表

```
for (auto &p : mp) {
    cout << p.first << " -> " << p.second << endl;
}
```

`p.first` 是键，`p.second` 是值。

------

## 3. 例子：练习哈希表基本用法

```
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string, int> mp;

    // 插入
    mp["apple"] = 3;
    mp["banana"] = 5;
    mp.insert({"orange", 7});

    // 查找
    if (mp.count("apple")) {
        cout << "apple 数量: " << mp["apple"] << endl;
    }

    // 遍历
    for (auto &p : mp) {
        cout << p.first << ": " << p.second << endl;
    }

    // 删除
    mp.erase("banana");
    cout << "删除banana后，大小: " << mp.size() << endl;

    return 0;
}
```

------

## 4. 在 `twoSum` 中如何用？

回顾 `twoSum`：

```
unordered_map<int,int> pos; // key: 数值，value: 下标
pos[nums[i]] = i;           // 存入哈希表
if (pos.count(need)) {      // 查找是否存在
    return {pos[need], i};  // 获取之前存的下标
}
```

可以看到，我们用到了：

- `unordered_map` 定义
- `[]` 插入/访问
- `count()` 判断是否存在

------

## 5. 常见注意点

- `unordered_map` **不保证顺序**，如果需要有序，用 `map`
- `[]` 访问不存在的键会插入默认值（0、空字符串等），避免时可用 `find()` 或 `count()`
- 哈希表对大数据很快，但会占用更多内存



## 例题：

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```



```
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 创建一个哈希表（unordered_map），用来存储 数值 -> 下标 的映射
        unordered_map<int, int> pos;

        // 遍历数组
        for (int i = 0; i < (int)nums.size(); i++) {
            int need = target - nums[i]; // 需要找到的另一个数

            // 检查哈希表中是否有需要的数
            if (pos.count(need)) {
                // 如果找到了，返回这两个数的下标
                return {pos[need], i};
            }

            // 如果没找到，把当前数和它的下标存入哈希表
            pos[nums[i]] = i;
        }

        // 题目保证一定有答案，这里不会执行
        return {};
    }
};

int main() {
    Solution s;
    vector<int> nums = {2,7,11,15};
    int target = 9;
    vector<int> ans = s.twoSum(nums, target);
    cout << "[" << ans[0] << ", " << ans[1] << "]" << endl;
    return 0;
}

```

